---
title: "Extracting Voronoi Polygons"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Extracting Voronoi Polygons}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
library(rvoronoi)
```

The original `voronoi()` method from Fortune's original C code returns only edge definitions 
i.e. two connected vertices which are part of the tessellation boundary.

But these edge definitions are uncorrelated - there's no way to tell which edges
make up each polygonal boundary as that information is not returned 
by the algorithm.

So given the list of edges, we need to reconstruct groups of edges which
make up the polygons.

The method used in this package to convert a list of uncorrelated edges to 
a list of polygons is from Jiang & Bunke's "An optimal 
algorithm for extracting the regions of a plane graph" (Pattern Recognition
Letters 14 (1993), p553-558).

This vignette illustrates this algorithm in R on a simple example edge list.


## Example edge list

```{r fig.height = 5, fig.width = 5}
# Vertices for a house
#     1   2  3    4  5
x <- c(0, 1, 1, 0.5, 0)
y <- c(0, 0, 1, 1.5, 1)

# Edge list = pairs of vertices
e <- matrix(c(
  1, 2, 
  2, 3, 
  3, 4, 
  4, 5, 
  5, 1,
  3, 5
), byrow = TRUE, ncol = 2) |>
  as.data.frame() |>
  setNames(c('v1', 'v2'))

# Plot the points and edges
plot(x, y, axes = FALSE, ann = FALSE)
segments(
  x[e$v1], y[e$v1],
  x[e$v2], y[e$v2]
)
text(x, y + 0.05, seq_along(x))
```

## Overview of method

* Phase 1: Find all the wedges
    1. Split undirected edge into two directed edges
    2. Add angle 
    3. Sort by v1, theta
    4. Form wedges
* Phase 2:  Group wedges into regions
    1. Sort the wedge list by v0, v1
    2. Mark all wedges as unused
    3. Find the next unused wedge - mark as 'used', add to region. If no unsed wedge, then algorithm complete
    4. Search for matching continuing wedge. E.g. if initial wedge is c(1, 4, 7), look for wedge c(4, 7, x). Add to region
    5. If new wedge matches original wedge, then: region is extracted. Go to 3 else: go to 4
    
```{r error=TRUE}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Phase 1: Find all the wedges
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# 1. Split undirected edge into two directed edges
e <- rbind(e, data.frame(v1 = e$v2, v2 = e$v1))


# 2 Add angle 
theta <- atan2(y[e$v2] - y[e$v1], x[e$v2] - x[e$v1])
theta <- ifelse(theta < 0, theta + 2 * pi, theta)

e$theta <- theta
e

# 3. Sort by v1, theta
e <- e[with(e, order(v1, theta)), ]

# 4. Form wedges
egroups <- split(e, e$v1)
egroups <- lapply(egroups, function(df) {
  df$v0 <- with(df, c(v2[length(v2)], v2[-length(v2)])) # Roll
  df
})
wedge <- do.call(rbind, egroups)
wedge <- wedge[, c('v0', 'v1', 'v2')]


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Phase 2:  Group wedges into regions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# List of regions.
# Each region is a list of wedge indices
regions <- list()

# 1. Sort the wedge list by v0, v1
#    Sort needed as actual lookup to find matching wedge should be done 
#    by binary search.
wedge <- wedge[with(wedge, order(v0, v1)), ]

# 2. Mark all wedges as unused
wedge$used <- FALSE

while(TRUE) {
  # 3. Find the next unused wedge - mark as 'used', add to region
  #    If no unused wedge, then algorithm complete
  orig <- head(which(!wedge$used), 1)
  if (length(orig) == 0) {
    message("All polygons extracted")
    break
  }
  region  <- c(orig); wedge$used[orig] <- TRUE
  current <- orig
  
  # 4. Search for matching continuing wedge.
  #    E.g. if initial wedge is c(1, 4, 7), look for wedge c(4, 7, x)
  #    Add to region
  while (TRUE) {
    match  <- with(wedge, which(!used & v0 == wedge$v1[current] & v1 == wedge$v2[current]))
    region <- c(region, match); wedge$used[match] <- TRUE
    current <- match
    
    # 5. If new wedge overlaps original wedge, 
    #       then: region is extracted. Go to 3
    #       else: go to 4
    if (wedge$v1[match] == wedge$v0[orig] & wedge$v2[match] == wedge$v1[orig]) {
      regions <- c(regions, list(region))
      message("Finished region: ", deparse1(region))
      break
    }
  } # Return to step 4
} # Return to step 3

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Convert the list of wedges for each region
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vidxs <- lapply(regions, function(region) {
  region_wedges <- wedge[region, ]
  region_verts  <- region_wedges$v1
  region_verts
})

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Convert vertex indices into actual coordinates
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
polygons <- lapply(vidxs, function(idxs) {
  data.frame(x = x[idxs], y = y[idxs])
})

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# The largest area is a container for the region *outside* all the 
# voronoi points. We don't want this, so remove the polygon with the 
# largest bounding box
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
areas <- vapply(polygons, function(p) {
  diff(range(p$x)) * diff(range(p$y))
}, double(1))
biggest <- which.max(areas)  


polygons <- polygons[-biggest]
polygons
```


```{r fig.height = 5, fig.width = 5}
plot(x, y, ann = FALSE, axes = FALSE)

cols <- terrain.colors(length(polygons))

for (i in seq_along(polygons)) {
  polygon(polygons[[i]], col = cols[i])
}
```










